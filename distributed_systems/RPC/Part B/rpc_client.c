/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h> // For close and read
#include <pthread.h> // For pthread functions
#include <rpc/rpc.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "rpc.h"



struct arg_struct{
	char *hostname;
	int client_name;
};



void *handle_request(void *args);


int
main (int argc, char *argv[]){
	struct arg_struct *arguments;
	int input_socket, accepted_socket, portnum;
	socklen_t client_len;
	int i=0;

	struct sockaddr_in server_address, client_address;
	pthread_t thread[20];

	if(argc < 3){
		printf("usage %s hostname port\n", argv[0]);
		exit(1);
	}

	input_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (input_socket < 0) {
        perror("[-] Error opening socket");
        exit(1);
    }
	bzero((char *) &server_address, sizeof(server_address));
	portnum = atoi(argv[2]);

	server_address.sin_family = AF_INET;
	server_address.sin_port = htons(portnum);
	server_address.sin_addr.s_addr=INADDR_ANY;

    if (bind(input_socket, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {
        perror("[-] Error  on binding");
        close(input_socket);
        exit(1);
    }

	listen(input_socket, 5);


	while(1){
		printf("Waiting for connection");
		client_len = sizeof(client_address);

		accepted_socket = accept(input_socket, (struct sockaddr *) &client_address, &client_len);
        if (accepted_socket < 0) {
            perror("[-] Error on accept");
            continue;
        }

		arguments = malloc(sizeof(struct arg_struct));
		if (arguments == NULL) {
            perror("[-] Error allocating memory");
            close(accepted_socket);
            continue;
        }
		arguments->hostname = argv[1];
		arguments->client_name = accepted_socket;

        if (pthread_create(&(thread[i++]), NULL, handle_request, (void *) arguments) != 0) {
            perror("[-] Error creating thread");
            close(accepted_socket);
            free(arguments);
            continue;
        }

		if(i >= 20){
            i = 0;
            while (i < 20) {
                pthread_join(thread[i++], NULL);
            }
            i = 0;
        }
	}

    close(input_socket);
    return 0;
}



void *handle_request(void *args){
	struct arg_struct *arguments = (struct arg_struct *)args;
	int client_socket = arguments->client_name;
	char *host = arguments->hostname;
	CLIENT *clnt;


	int choice, size;
	float result_mean;
	struct min_max result_min_max;
	struct scale_result result_scale;
	struct y_vector vector;
	struct scale_input scale_input;

	if ((clnt = clnt_create(host, calc_mean_PROG, calc_mean_VERS, "udp")) == NULL){
		clnt_pcreateerror(host);
		close(client_socket);
		free(arguments);
		pthread_exit(NULL);
	}

	//Get the user choice
	read(client_socket, &choice, sizeof(int));

	switch(choice){
		case 1:
		//Read and allocate the matrix
			read(client_socket, &size, sizeof(int));
			vector.length = size;
			vector.data.data_len = size;
			vector.data.data_val = malloc(size * sizeof(int));
			read(client_socket, vector.data.data_val, size*sizeof(int));
		//Call the server for the result and send it back to the socket client			
			result_mean = *calc_mean_1(&vector, clnt);
			send(client_socket, &result_mean, sizeof(float), 0);
		//Free the memory	
			free(vector.data.data_val);
			break;
		case 2:
			//Read and allocate the matrix
			read(client_socket, &size, sizeof(int));
			vector.length = size;
			vector.data.data_len = size;
			vector.data.data_val = malloc(size * sizeof(int));
			read(client_socket, vector.data.data_val, size*sizeof(int));
			//Calculate the result
			result_min_max = *find_min_max_1(&vector, clnt);
			send(client_socket, result_min_max.values, 2*sizeof(int), 0);
			free(vector.data.data_val);
			break;
		case 3:
			//Read the matrix
			read(client_socket, &size, sizeof(int));
			scale_input.length = size;
			scale_input.data.data_len = size;
			scale_input.data.data_val = malloc(size * sizeof(int));
			read(client_socket, scale_input.data.data_val, size*sizeof(int));
			//Read the real number a
			read(client_socket, &scale_input.a, sizeof(double));
			//Calculate the result
			result_scale = *scale_multiply_1(&scale_input, clnt);
			//Send the result to the socket server
			send(client_socket, result_scale.scale_input.scale_input_val, size * sizeof(double), 0);
			//Free memory
			free(scale_input.data.data_val);
			free(result_scale.scale_input.scale_input_val);
			break;;
	}
	clnt_destroy(clnt);
	close(client_socket);
	free(arguments);
	pthread_exit(NULL);
}